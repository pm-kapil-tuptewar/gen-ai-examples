P/E Ratio:
Price to Earnings Ratio = Stock Price ÷ Earnings Per Share. It shows how much investors are paying for ₹1 of profit.
Lower P/E (<15) can suggest undervalued stock. Higher P/E (>25) may indicate growth expectations or overvaluation.

Book Value:
Net worth of the company per share (Assets - Liabilities) ÷ Total shares.
If Current Price < Book Value → stock may be undervalued.Here, Price ₹189 > Book ₹127 → priced above its assets, but not excessively.

Balance sheet 

Cash Flow 
Cash Flow from Operating Activities : 
    Shows if core business operations are generating cash.
    Consistently positive CFO is a strong sign of a sustainable business.
    If CFO is negative repeatedly, it could mean trouble—even if profits are reported (due to non-cash items like depreciation).

import os
import streamlit as st
from bs4 import BeautifulSoup
from dotenv import load_dotenv
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate, SystemMessagePromptTemplate, HumanMessagePromptTemplate

# Load .env
load_dotenv()
openai_api_key = os.getenv("OPENAI_API_KEY")
base_url = os.getenv('OPENAI_BASE_URL') 

# ==== 1. Extract financial info from HTML ====
from bs4 import BeautifulSoup

def extract_financial_info(html_content):
    soup = BeautifulSoup(html_content, "html.parser")

    info = {}

    # 1. Company Name
    company_name = soup.find("h1")
    company_name = company_name.get_text(strip=True) if company_name else "Unknown Company"
    info["Company Name"] = company_name

    # 2. Financial Key-Value Ratios
    ratios = soup.find_all("li", class_="flex flex-space-between")
    for ratio in ratios:
        label_tag = ratio.find("span", class_="name")
        value_tag = ratio.find("span", class_="nowrap value")
        if label_tag and value_tag:
            label = label_tag.get_text(strip=True)
            value = value_tag.get_text(" ", strip=True).replace("\n", "")
            info[label] = value

    # 3. Company Profile Details (About + Key Business Highlights)
    profile_div = soup.find("div", class_="company-profile")
    if profile_div:
        about = profile_div.find("div", class_="sub show-more-box about")
        key_points = profile_div.find("div", class_="sub commentary always-show-more-box")

        if about and about.text.strip():
            info["About Company"] = about.text.strip()

        if key_points and key_points.text.strip():
            info["Key Business Highlights"] = key_points.text.strip()

    # 4. Pros and Cons Section
    pros_div = soup.find("div", class_="pros")
    cons_div = soup.find("div", class_="cons")

    if pros_div:
        pros_list = [li.get_text(strip=True) for li in pros_div.find_all("li")]
        if pros_list:
            info["Pros"] = "\n".join([f"- {item}" for item in pros_list])

    if cons_div:
        cons_list = [li.get_text(strip=True) for li in cons_div.find_all("li")]
        if cons_list:
            info["Cons"] = "\n".join([f"- {item}" for item in cons_list])

    # 5. Peer Comparison Table (under div#peers)
    peers_section = soup.find("section", id="peers")
    if peers_section:
        peer_table = peers_section.find("table")
        if peer_table:
            rows = peer_table.find_all("tr")
            if len(rows) > 1:
                headers = [th.get_text(strip=True).replace("\n", " ") for th in rows[0].find_all("th")]
                peer_data = []

                for row in rows[1:]:
                    cols = row.find_all("td")
                    if len(cols) == len(headers):
                        row_data = [col.get_text(strip=True) for col in cols]
                        peer_data.append(dict(zip(headers, row_data)))
                    elif len(cols) == len(headers) - 1:  # Some rows like median row miss S.No.
                        row_data = ["-"] + [col.get_text(strip=True) for col in cols]
                        peer_data.append(dict(zip(headers, row_data)))

                # Format for LLM: as newline-separated peer comparisons
                peer_summary = "\n".join(
                    [", ".join(f"{k}: {v}" for k, v in row.items()) for row in peer_data]
                )
                info["Peer Comparison"] = peer_summary   

    # 6. Profit & Loss Tables under <section id="profit-loss">
    profit_loss_section = soup.find("section", id="profit-loss")
    if profit_loss_section:
        data_tables = profit_loss_section.find_all("table", class_="data-table")
        pl_data_combined = []
        for table in data_tables:
            thead = table.find("thead")
            tbody = table.find("tbody")
            if not thead or not tbody:
                continue

            # Extract years from thead
            header_cells = thead.find_all("th")
            years = [cell.get_text(strip=True) for cell in header_cells[1:]]

            # Extract financial metrics from tbody
            for row in tbody.find_all("tr"):
                cells = row.find_all(["td", "th"])
                if len(cells) < 2:
                    continue
                metric = cells[0].get_text(strip=True)
                values = [cell.get_text(strip=True) for cell in cells[1:]]
                year_value_pairs = [f"{y}: {v}" for y, v in zip(years, values)]
                formatted_row = f"{metric} - " + ", ".join(year_value_pairs)
                pl_data_combined.append(formatted_row)

        if pl_data_combined:
            info["Profit & Loss Summary"] = "\n".join(pl_data_combined)

    # 7. Quarterly Results from <section id="quarters">
    quarters_section = soup.find("section", id="quarters")
    if quarters_section:
        table = quarters_section.find("table", class_="data-table")
        if table:
            thead = table.find("thead")
            tbody = table.find("tbody")
            if thead and tbody:
                header_cells = thead.find_all("th")
                quarters = [cell.get_text(strip=True) for cell in header_cells[1:]]

                quarterly_data = []
                for row in tbody.find_all("tr"):
                    cells = row.find_all(["td", "th"])
                    if len(cells) < 2:
                        continue
                    category = cells[0].get_text(strip=True)
                    values = [cell.get_text(strip=True) for cell in cells[1:]]
                    qtr_value_pairs = [f"{q}: {v}" for q, v in zip(quarters, values)]
                    formatted_row = f"{category} - " + ", ".join(qtr_value_pairs)
                    quarterly_data.append(formatted_row)

                if quarterly_data:
                    info["Quarterly Results Summary"] = "\n".join(quarterly_data)

    # 8. Shareholding Pattern under <section id="shareholding">
    shareholding_section = soup.find("section", id="shareholding")
    if shareholding_section:
        table = shareholding_section.find("table", class_="data-table")
        if table:
            thead = table.find("thead")
            tbody = table.find("tbody")
            if thead and tbody:
                # Extract periods (e.g., June 2022, Sep 2022)
                header_cells = thead.find_all("th")
                periods = [cell.get_text(strip=True) for cell in header_cells[1:]]

                shareholding_data = []
                for row in tbody.find_all("tr"):
                    cells = row.find_all(["td", "th"])
                    if len(cells) < 2:
                        continue
                    category = cells[0].get_text(strip=True)
                    values = [cell.get_text(strip=True) for cell in cells[1:]]
                    period_value_pairs = [f"{p}: {v}" for p, v in zip(periods, values)]
                    formatted_row = f"{category} - " + ", ".join(period_value_pairs)
                    shareholding_data.append(formatted_row)

                if shareholding_data:
                    info["Shareholding Pattern"] = "\n".join(shareholding_data)

    # 9. Balance Sheet under <section id="balance-sheet">
    balance_sheet_section = soup.find("section", id="balance-sheet")
    if balance_sheet_section:
        balance_sheet_table = balance_sheet_section.find("table", class_="data-table")
        if balance_sheet_table:
            thead = balance_sheet_table.find("thead")
            tbody = balance_sheet_table.find("tbody")
            if thead and tbody:
                header_cells = thead.find_all("th")
                years = [cell.get_text(strip=True) for cell in header_cells[1:]]

                balance_data = []
                for row in tbody.find_all("tr"):
                    cells = row.find_all(["td", "th"])
                    if len(cells) < 2:
                        continue
                    category = cells[0].get_text(strip=True)
                    values = [cell.get_text(strip=True) for cell in cells[1:]]
                    year_value_pairs = [f"{y}: {v}" for y, v in zip(years, values)]
                    formatted_row = f"{category} - " + ", ".join(year_value_pairs)
                    balance_data.append(formatted_row)

                if balance_data:
                    info["Balance Sheet Summary"] = "\n".join(balance_data)

    # 10. Cash Flow Table under <section id="cash-flow">
    cash_flow_section = soup.find("section", id="cash-flow")
    if cash_flow_section:
        table = cash_flow_section.find("table", class_="data-table")
        if table:
            thead = table.find("thead")
            tbody = table.find("tbody")
            if thead and tbody:
                # Extract years from the header row (ignoring the first column)
                header_cells = thead.find_all("th")
                years = [cell.get_text(strip=True) for cell in header_cells[1:]]

                cash_flow_data = []
                for row in tbody.find_all("tr"):
                    cells = row.find_all(["td", "th"])
                    if len(cells) < 2:
                        continue
                    category = cells[0].get_text(strip=True)
                    values = [cell.get_text(strip=True) for cell in cells[1:]]
                    year_value_pairs = [f"{y}: {v}" for y, v in zip(years, values)]
                    formatted_row = f"{category} - " + ", ".join(year_value_pairs)
                    cash_flow_data.append(formatted_row)

                if cash_flow_data:
                    info["Cash Flow Summary"] = "\n".join(cash_flow_data)                

    return info


# ==== 2. Build LangChain Prompt ====
def build_langchain_prompt(info_dict, question):
    context = "\n".join([f"{k}: {v}" for k, v in info_dict.items()])

    system_template = """
        You are a financial analysis assistant designed to interpret structured data about a company. The provided context includes information such as current stock price, PE ratio, market cap, all-time high/low, book value, ROCE, ROE, peer comparisons, quarterly financial results, shareholding patterns, company pros and cons, and business highlights.
        Your task is to respond in a **precise and context-aware** manner:

        ---

        #### 🎯 **Specific Questions:**
        If the user asks a specific question (e.g.,  
        - *“What is the current stock price?”*,  
        - *“Show me the last quarter’s result”*,  
        - *“What is the promoter holding trend?”*),  
        respond with only the **relevant facts** needed to directly answer that query — avoid adding unrelated context or summaries.

        ---

        #### 📊 **General or Open-ended Questions:**
        If the user asks a broader question (e.g.,  
        - *“Tell me about this stock/company”*,  
        - *“Is this a good stock?”*,  
        - *“What is the overall performance of this stock?”*),  
        then generate a concise and holistic summary highlighting:

        - **Business Overview** (if available)  
        - **Financial Strengths** (ROCE, ROE, Book Value, PE Ratio, Market Cap)  
        - **Quarterly Results Trend** (growth or decline across key metrics)  
        - **Shareholding Pattern Trend** (especially year-on-year promoter or institutional changes)  
        - **Peer Comparison** (where the company stands vs competitors)  
        - **Pros and Cons**  
        - **Valuation insight** (e.g., if PE ratio is high vs peers)

        Conclude with a **recommendation** only if year-on-year financials and shareholding trends indicate strong or improving performance:
        > “Based on the overall fundamentals and consistent performance, this stock appears strong and could be a good candidate for long-term portfolios.”

        If the data reveals **inconsistencies, declines, or volatility**, cautiously mention those instead of giving a direct buy recommendation.

        ---

        #### 🛑 Do Not:
        - Make up data or interpretations not grounded in the provided information.
        - Provide investment advice without basis in the context.
        - Repeat all company details for every question unless explicitly requested.
    """

    human_template = f"""
    Context:
    {context}

    Question: {question}
    """

    system_prompt = SystemMessagePromptTemplate.from_template(system_template)
    human_prompt = HumanMessagePromptTemplate.from_template(human_template)
    chat_prompt = ChatPromptTemplate.from_messages([system_prompt, human_prompt])

    return chat_prompt.format_messages()

# ==== 3. Ask LangChain LLM ====
def ask_with_langchain(info_dict, question):
    llm = ChatOpenAI(
        model_name="(paid) gpt-4o",
        temperature=0.2,
        openai_api_key=openai_api_key,
        base_url= base_url
    )
    prompt = build_langchain_prompt(info_dict, question)
    response = llm(prompt)
    return response.content.strip()

# ==== 4. Streamlit UI ====
st.set_page_config(page_title="📊 HTML Stock Q&A via LangChain", layout="centered")
st.title("📈 Screener Stock Analyzer (LangChain Powered)")

uploaded_file = st.file_uploader("Upload Screener HTML file", type=["html"])
question = st.text_input("Ask your question (e.g. What is the market cap?)")

if not openai_api_key:
    st.warning("⚠️ OpenAI API Key not found. Please check your `.env` file.")
elif uploaded_file:
    html_bytes = uploaded_file.read()
    extracted_info = extract_financial_info(html_bytes)
    st.write('extracted_info :::', extracted_info)
    st.subheader("📋 Extracted Info")
    # st.write('extracted_info', extracted_info)
    #for k, v in extracted_info.items():
    #    st.markdown(f"- **{k}**: {v}")

    if question:
        with st.spinner("Generating answer..."):
            try:
                answer = ask_with_langchain(extracted_info, question)
                st.subheader("💬 Answer")
                st.success(answer)
            except Exception as e:
                st.error(f"❌ Error: {e}")
else:
    st.info("📂 Please upload a Screener HTML file to begin.")
